{"name": "concurrent-writes-integrity", "description": "Multiple goroutines writing to different keys concurrently", "given": "Empty database with unique temp directory", "when": "10 goroutines each write to their own key simultaneously", "then": "All 10 keys exist with correct values, no corruption", "validates": "Do() handles concurrent writers without data corruption", "runtime_ms": 700}
{"name": "lock-contention-fallback", "description": "DoWithFallback behavior when write lock is held", "given": "Database with one goroutine holding write lock for 500ms", "when": "Another goroutine calls DoWithFallback with WithNoWriteRetry()", "then": "Falls back immediately (or gets write if SQLite WAL allows), can still read data", "validates": "DoWithFallback graceful degradation", "runtime_ms": 1100, "note": "SQLite WAL may allow concurrent writes"}
{"name": "read-write-isolation", "description": "Writers not blocked by active readers", "given": "Database with 5 readers holding connections for 100ms each", "when": "Writer attempts to write while readers are active", "then": "Write completes in <500ms, not blocked by readers", "validates": "SQLite WAL allows writes during reads", "runtime_ms": 700}
{"name": "rapid-cycle-integrity", "description": "Data integrity under rapid open/write/close cycles", "given": "Fresh database, 500 iterations", "when": "Each iteration: Do() writes key, DoReadOnly() verifies immediately", "then": "All 500 keys present and correct at end", "validates": "Do() properly releases resources, no corruption from rapid cycling", "runtime_ms": 260000}
{"name": "starvation-analysis", "description": "Neither readers nor writers starve under contention", "given": "Database with 2 writers and 5 readers running for 3 seconds", "when": "All goroutines continuously perform operations", "then": "Writers complete 10+ ops, readers complete 50+ ops", "validates": "Fair scheduling under contention", "runtime_ms": 3400}
{"name": "wal-recovery", "description": "Data persists across database reopens", "given": "Database with 100 keys written in single Do()", "when": "Database reopened with DoReadOnly()", "then": "All 100 keys present and verified", "validates": "SQLite WAL recovery and data durability", "runtime_ms": 800}
{"name": "transaction-within-do", "description": "Multi-key operations within single Do() are consistent", "given": "Database with 3 related keys (name, age, city)", "when": "10 sequential Do() calls, each updating all 3 keys", "then": "Final state has all 3 keys from same iteration", "validates": "Operations within single Do() are atomic", "runtime_ms": 3600}
{"name": "large-value-handling", "description": "1MB values write and read correctly", "given": "Empty database", "when": "Write 1MB random data, read it back", "then": "Read value equals written value byte-for-byte", "validates": "Large value handling without corruption", "runtime_ms": 800}
{"name": "mixed-operations-stress", "description": "All operation types running concurrently", "given": "Database with 2 Do() writers, 3 DoReadOnly() readers, 2 DoWithFallback() users", "when": "All run for 3 seconds", "then": "100+ total operations, database remains usable", "validates": "System stability under mixed workload", "runtime_ms": 3900}
{"name": "delete-under-contention", "description": "Deletes while reads are happening", "given": "Database seeded with 50 keys, 1 deleter, 3 readers", "when": "All run for 2 seconds", "then": "5+ deletes and 5+ reads complete", "validates": "Deletes don't corrupt during concurrent reads", "runtime_ms": 2600}
{"name": "the-conspiracy", "description": "Everything at once: large values, many writers, deletions, reads", "given": "Database with 2 large writers, 3 small writers, 2 deleters, 4 readers, 2 fallback users", "when": "All run for 5 seconds", "then": "200+ operations, database survives, post-test write succeeds", "validates": "System survives worst-case concurrent stress", "runtime_ms": 6200}
{"name": "write-ordering", "description": "Sequential writes maintain order", "given": "Empty database", "when": "100 sequential Do() calls, each writing increasing number to same key", "then": "Final value is 99 (the last written)", "validates": "Sequential writes are not reordered", "runtime_ms": 31000}
