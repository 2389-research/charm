{"name": "concurrent-writes-integrity", "description": "Multiple goroutines writing to different keys concurrently", "given": "Empty database with unique temp directory", "when": "10 goroutines each write to their own key simultaneously", "then": "All 10 keys exist with correct values, no corruption", "validates": "Do() handles concurrent writers without data corruption", "runtime_ms": 700}
{"name": "lock-contention-fallback", "description": "DoWithFallback behavior when write lock is held", "given": "Database with one goroutine holding write lock for 500ms", "when": "Another goroutine calls DoWithFallback with WithNoWriteRetry()", "then": "Falls back immediately (or gets write if SQLite WAL allows), can still read data", "validates": "DoWithFallback graceful degradation", "runtime_ms": 1100, "note": "SQLite WAL may allow concurrent writes"}
{"name": "read-write-isolation", "description": "Writers not blocked by active readers", "given": "Database with 5 readers holding connections for 100ms each", "when": "Writer attempts to write while readers are active", "then": "Write completes in <500ms, not blocked by readers", "validates": "SQLite WAL allows writes during reads", "runtime_ms": 700}
{"name": "rapid-cycle-integrity", "description": "Data integrity under rapid open/write/close cycles", "given": "Fresh database, 500 iterations", "when": "Each iteration: Do() writes key, DoReadOnly() verifies immediately", "then": "All 500 keys present and correct at end", "validates": "Do() properly releases resources, no corruption from rapid cycling", "runtime_ms": 260000}
{"name": "starvation-analysis", "description": "Neither readers nor writers starve under contention", "given": "Database with 2 writers and 5 readers running for 3 seconds", "when": "All goroutines continuously perform operations", "then": "Writers complete 10+ ops, readers complete 50+ ops", "validates": "Fair scheduling under contention", "runtime_ms": 3400}
{"name": "wal-recovery", "description": "Data persists across database reopens", "given": "Database with 100 keys written in single Do()", "when": "Database reopened with DoReadOnly()", "then": "All 100 keys present and verified", "validates": "SQLite WAL recovery and data durability", "runtime_ms": 800}
{"name": "transaction-within-do", "description": "Multi-key operations within single Do() are consistent", "given": "Database with 3 related keys (name, age, city)", "when": "10 sequential Do() calls, each updating all 3 keys", "then": "Final state has all 3 keys from same iteration", "validates": "Operations within single Do() are atomic", "runtime_ms": 3600}
{"name": "large-value-handling", "description": "1MB values write and read correctly", "given": "Empty database", "when": "Write 1MB random data, read it back", "then": "Read value equals written value byte-for-byte", "validates": "Large value handling without corruption", "runtime_ms": 800}
{"name": "mixed-operations-stress", "description": "All operation types running concurrently", "given": "Database with 2 Do() writers, 3 DoReadOnly() readers, 2 DoWithFallback() users", "when": "All run for 3 seconds", "then": "100+ total operations, database remains usable", "validates": "System stability under mixed workload", "runtime_ms": 3900}
{"name": "delete-under-contention", "description": "Deletes while reads are happening", "given": "Database seeded with 50 keys, 1 deleter, 3 readers", "when": "All run for 2 seconds", "then": "5+ deletes and 5+ reads complete", "validates": "Deletes don't corrupt during concurrent reads", "runtime_ms": 2600}
{"name": "the-conspiracy", "description": "Everything at once: large values, many writers, deletions, reads", "given": "Database with 2 large writers, 3 small writers, 2 deleters, 4 readers, 2 fallback users", "when": "All run for 5 seconds", "then": "200+ operations, database survives, post-test write succeeds", "validates": "System survives worst-case concurrent stress", "runtime_ms": 6200}
{"name": "write-ordering", "description": "Sequential writes maintain order", "given": "Empty database", "when": "100 sequential Do() calls, each writing increasing number to same key", "then": "Final value is 99 (the last written)", "validates": "Sequential writes are not reordered", "runtime_ms": 31000}
{"name": "sqlite-synchronous-mode", "description": "PRAGMA synchronous=NORMAL is set for durability", "given": "Fresh SQLite database", "when": "Query PRAGMA synchronous", "then": "Returns 1 (NORMAL mode)", "validates": "SQLite durability settings applied", "runtime_ms": 5}
{"name": "sync-lock-acquisition", "description": "Basic sync lock acquire/release", "given": "Empty sync_lock table", "when": "Acquire lock, verify holder, release lock", "then": "Lock acquired, holder matches, lock released", "validates": "Sync lock basic functionality", "runtime_ms": 5}
{"name": "sync-lock-expiry", "description": "Expired locks can be taken over", "given": "Sync lock held with expired timestamp", "when": "New holder attempts to acquire", "then": "New holder takes over the lock", "validates": "Lock expiry prevents deadlocks", "runtime_ms": 5}
{"name": "sync-lock-contention", "description": "Concurrent lock attempts", "given": "Empty sync_lock table", "when": "10 goroutines simultaneously try to acquire lock", "then": "Exactly 1 succeeds, others fail", "validates": "Lock exclusivity under contention", "runtime_ms": 10}
{"name": "pending-ops-recording", "description": "Write operations are tracked durably", "given": "Empty pending_ops table", "when": "Record 3 pending ops (2 sets, 1 delete)", "then": "3 ops in pending_ops table", "validates": "Pending ops are recorded", "runtime_ms": 5}
{"name": "pending-ops-cleared-after-sync", "description": "Pending ops cleared on successful backup", "given": "5 pending ops in table", "when": "Simulate successful sync (clear pending ops)", "then": "0 ops remain in table", "validates": "Pending ops cleanup after sync", "runtime_ms": 5}
{"name": "pending-ops-durability", "description": "Pending ops survive database close/reopen", "given": "10 pending ops written to database", "when": "Close database, reopen", "then": "10 pending ops still present", "validates": "Pending ops survive process restart", "runtime_ms": 10}
{"name": "phase1-schema-tables", "description": "All Phase 1 tables exist in schema", "given": "Fresh database with schema applied", "when": "Query sqlite_master for table names", "then": "kv, meta, sync_lock, pending_ops all exist", "validates": "Schema migration complete", "runtime_ms": 5}
{"name": "doctor-healthy-database", "description": "Doctor reports healthy for clean database", "given": "Fresh database with no issues", "when": "Call Doctor()", "then": "IntegrityOK=true, PendingOpsCount=0, IsHealthy()=true", "validates": "Doctor correctly identifies healthy state", "runtime_ms": 10}
{"name": "doctor-pending-ops-count", "description": "Doctor reports pending ops count", "given": "Database with 5 pending ops", "when": "Call Doctor()", "then": "PendingOpsCount=5, OldestPendingOp is set", "validates": "Doctor counts pending ops", "runtime_ms": 10}
{"name": "doctor-sync-lock-status", "description": "Doctor reports active sync lock", "given": "Database with active sync lock", "when": "Call Doctor()", "then": "SyncLockHeld=true, SyncLockHolder set", "validates": "Doctor detects sync lock", "runtime_ms": 10}
{"name": "doctor-expired-lock-ignored", "description": "Doctor ignores expired sync locks", "given": "Database with expired sync lock", "when": "Call Doctor()", "then": "SyncLockHeld=false", "validates": "Doctor ignores stale locks", "runtime_ms": 10}
{"name": "doctor-old-pending-ops-warning", "description": "Doctor warns about old pending ops", "given": "Database with pending ops older than 24h", "when": "Call Doctor()", "then": "Warning about old pending ops in result", "validates": "Doctor warns about stale pending ops", "runtime_ms": 10}
{"name": "doctor-string-output", "description": "Doctor result has readable string output", "given": "DoctorResult with various states", "when": "Call String()", "then": "Human-readable output with checkmarks and warnings", "validates": "Doctor result is user-friendly", "runtime_ms": 5}
